(()=>{"use strict";var e={d:(t,a)=>{for(var o in a)e.o(a,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:a[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{RequireConfiguration:()=>_,RequireLoad:()=>A,RequireMethods:()=>J,options:()=>v});const a=("undefined"!=typeof window?window:global).MathJax._.components.global,o=(a.GLOBAL,a.isObject,a.combineConfig,a.combineDefaults,a.combineWithMathJax),r=(a.MathJax,MathJax._.input.tex.HandlerTypes),n=r.ConfigurationType,i=r.HandlerType,s=MathJax._.input.tex.Configuration,p=s.Configuration,u=s.ConfigurationHandler,l=(s.ParserConfiguration,MathJax._.input.tex.TokenMap),c=(l.parseResult,l.AbstractTokenMap,l.RegExpMap,l.AbstractParseMap,l.CharacterMap,l.DelimiterMap,l.MacroMap,l.CommandMap),d=(l.EnvironmentMap,MathJax._.input.tex.TexError.default),f=("undefined"!=typeof window?window:global).MathJax._.components.startup,g=(f.Startup,f.MathJax),h=(f.CONFIG,MathJax._.components.package),x=(h.PackageError,h.Package),m=("undefined"!=typeof window?window:global).MathJax._.components.loader,M=(m.PathFilters,m.Loader),O=(m.MathJax,m.CONFIG),y=MathJax._.mathjax.mathjax,b=MathJax._.util.Options,w=(b.isObject,b.APPEND,b.REMOVE,b.OPTIONS,b.Expandable,b.expandable),q=(b.makeArray,b.keys,b.copy,b.insert,b.defaultOptions,b.userOptions,b.selectOptions,b.selectOptionsFromKeys,b.separateOptions,b.lookup,g.config);function k(e,t){const a=e.parseOptions.options.require,o=e.parseOptions.packageData.get("require").required,r=t.substring(a.prefix.length);if(o.indexOf(r)<0){o.push(r);let a=function(e,t=[]){const a=e.parseOptions.options.require.prefix,o=[];for(const r of t)if(r.substring(0,a.length)===a)try{k(e,r)}catch(e){if(!e.retry)throw e;o.push(e.retry)}return o.length?Promise.all(o):null}(e,O.dependencies[t]);a?y.retryAfter(a.then((()=>P(e,t,r)))):P(e,t,r)}}function P(e,t,a){const o=u.get(a);if(o){let r=q[t]||{};o.options&&1===Object.keys(o.options).length&&o.options[a]&&(r={[a]:r}),e.configuration.add(a,e,r);const n=e.parseOptions.packageData.get("require").configured;o.preprocessors.length&&!n.has(a)&&(n.set(a,!0),y.retryAfter(Promise.resolve()))}}function A(e,t){var a,o,r,n;const i=e.options.require,s=i.allow,p=("["===t.substring(0,1)?"":i.prefix)+t;if(!(s.hasOwnProperty(p)?s[p]:s.hasOwnProperty(t)?s[t]:i.defaultAllow))throw new d("BadRequire",'Extension "%1" is not allowed to be loaded',p);x.packages.has(p)||y.retryAfter(M.load(p));const u=null===(a=O[p])||void 0===a?void 0:a.rendererExtensions;null===(n=null===(r=null===(o=g.startup.document)||void 0===o?void 0:o.menu)||void 0===r?void 0:r.addRequiredExtensions)||void 0===n||n.call(r,u),k(e.configuration.packageData.get("require").jax,p)}const J={Require(e,t){const a=e.GetArgument(t);if(a.match(/[^_a-zA-Z0-9]/)||""===a)throw new d("BadPackageName","Argument for %1 is not a valid package name",t);A(e,a),e.Push(e.itemFactory.create("null"))}},v={require:{allow:w({base:!1,"all-packages":!1,autoload:!1,configmacros:!1,tagformat:!1,setoptions:!1,texhtml:!1}),defaultAllow:!0,prefix:"tex"}};new c("require",{require:J.Require});const _=p.create("require",{[n.HANDLER]:{[i.MACRO]:["require"]},config:function(e,t){t.parseOptions.packageData.set("require",{jax:t,required:[...t.options.packages],configured:new Map});const a=t.parseOptions.options.require,o=a.prefix;if(o.match(/[^_a-zA-Z0-9]/))throw Error("Illegal characters used in \\require prefix");O.paths[o]||(O.paths[o]="[mathjax]/input/tex/extensions"),a.prefix="["+o+"]/"},options:v});MathJax.loader&&MathJax.loader.checkVersion("[tex]/require","4.0.0-beta.7","tex-extension"),o({_:{input:{tex:{require:{RequireConfiguration:t}}}}})})();