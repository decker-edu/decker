(()=>{"use strict";var e={d:(t,a)=>{for(var o in a)e.o(a,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:a[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{RequireConfiguration:()=>k,RequireLoad:()=>q,RequireMethods:()=>w,options:()=>y});const a=("undefined"!=typeof window?window:global).MathJax._.components.global,o=(a.GLOBAL,a.isObject,a.combineConfig,a.combineDefaults,a.combineWithMathJax),r=a.MathJax,n=MathJax._.input.tex.Configuration,i=n.Configuration,s=n.ConfigurationHandler,p=(n.ParserConfiguration,MathJax._.input.tex.TokenMap),u=(p.parseResult,p.AbstractTokenMap,p.RegExpMap,p.AbstractParseMap,p.CharacterMap,p.DelimiterMap,p.MacroMap,p.CommandMap),c=(p.EnvironmentMap,MathJax._.input.tex.TexError.default),l=MathJax._.components.package,f=(l.PackageError,l.Package),d=("undefined"!=typeof window?window:global).MathJax._.components.loader,g=(d.PathFilters,d.Loader),x=(d.MathJax,d.CONFIG),h=MathJax._.mathjax.mathjax,m=MathJax._.util.Options,M=(m.isObject,m.APPEND,m.REMOVE,m.OPTIONS,m.Expandable,m.expandable),O=(m.makeArray,m.keys,m.copy,m.insert,m.defaultOptions,m.userOptions,m.selectOptions,m.selectOptionsFromKeys,m.separateOptions,m.lookup,r.config);function b(e,t){const a=e.parseOptions.options.require,o=e.parseOptions.packageData.get("require").required,r=t.substr(a.prefix.length);if(o.indexOf(r)<0){o.push(r),function(e,t=[]){const a=e.parseOptions.options.require.prefix;for(const o of t)o.substr(0,a.length)===a&&b(e,o)}(e,x.dependencies[t]);const a=s.get(r);if(a){let o=O[t]||{};a.options&&1===Object.keys(a.options).length&&a.options[r]&&(o={[r]:o}),e.configuration.add(r,e,o);const n=e.parseOptions.packageData.get("require").configured;a.preprocessors.length&&!n.has(r)&&(n.set(r,!0),h.retryAfter(Promise.resolve()))}}}function q(e,t){const a=e.options.require,o=a.allow,r=("["===t.substr(0,1)?"":a.prefix)+t;if(!(o.hasOwnProperty(r)?o[r]:o.hasOwnProperty(t)?o[t]:a.defaultAllow))throw new c("BadRequire",'Extension "%1" is not allowed to be loaded',r);f.packages.has(r)?b(e.configuration.packageData.get("require").jax,r):h.retryAfter(g.load(r))}const w={Require(e,t){const a=e.GetArgument(t);if(a.match(/[^_a-zA-Z0-9]/)||""===a)throw new c("BadPackageName","Argument for %1 is not a valid package name",t);q(e,a)}},y={require:{allow:M({base:!1,"all-packages":!1,autoload:!1,configmacros:!1,tagformat:!1,setoptions:!1,texhtml:!1}),defaultAllow:!0,prefix:"tex"}};new u("require",{require:"Require"},w);const k=i.create("require",{handler:{macro:["require"]},config:function(e,t){t.parseOptions.packageData.set("require",{jax:t,required:[...t.options.packages],configured:new Map});const a=t.parseOptions.options.require,o=a.prefix;if(o.match(/[^_a-zA-Z0-9]/))throw Error("Illegal characters used in \\require prefix");x.paths[o]||(x.paths[o]="[mathjax]/input/tex/extensions"),a.prefix="["+o+"]/"},options:y});MathJax.loader&&MathJax.loader.checkVersion("[tex]/require","4.0.0-beta.4","tex-extension"),o({_:{input:{tex:{require:{RequireConfiguration:t}}}}})})();