(()=>{"use strict";var t={d:(e,n)=>{for(var a in n)t.o(n,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{UnicodeConfiguration:()=>C});const n=("undefined"!=typeof window?window:global).MathJax._.components.global,a=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),i=(n.MathJax,MathJax._.input.tex.HandlerTypes),o=i.ConfigurationType,r=i.HandlerType,c=MathJax._.input.tex.Configuration,s=c.Configuration,l=(c.ConfigurationHandler,c.ParserConfiguration,MathJax._.input.tex.TexError.default),u=MathJax._.input.tex.TokenMap,d=(u.parseResult,u.AbstractTokenMap,u.RegExpMap,u.AbstractParseMap,u.CharacterMap,u.DelimiterMap,u.MacroMap,u.CommandMap),m=(u.EnvironmentMap,MathJax._.input.tex.UnitUtil.UnitUtil),h=MathJax._.input.tex.NodeUtil.default,p=MathJax._.util.Entities,f=(p.options,p.entities,p.add,p.remove,p.translate,p.numeric),g=MathJax._.input.tex.base.BaseConfiguration,x=g.Other;g.BaseTags,g.BaseConfiguration;let M={};const b={Unicode(t,e){let n=t.GetBrackets(e),a=null,i="";if(n&&(n.replace(/ /g,"").match(/^(\d+(\.\d*)?|\.\d+),(\d+(\.\d*)?|\.\d+)$/)?(a=n.replace(/ /g,"").split(/,/),i=t.GetBrackets(e)):i=n),i.match(/;/))throw new l("BadFont","Font name for %1 can't contain semicolons",t.currentCS);let o=m.trimSpaces(t.GetArgument(e)).replace(/^0x/,"x");if(!o.match(/^(x[0-9A-Fa-f]+|[0-9]+)$/))throw new l("BadUnicode","Argument to %1 must be a number",t.currentCS);let r=parseInt(o.match(/^x/)?"0"+o:o);M[r]?i||(i=M[r][2]):M[r]=[800,200,i,r],a&&(M[r][0]=Math.floor(1e3*parseFloat(a[0])),M[r][1]=Math.floor(1e3*parseFloat(a[1])));let c=t.stack.env.font,s={};i?(M[r][2]=s.fontfamily=i.replace(/'/g,"'"),c&&(c.match(/bold/)&&(s.fontweight="bold"),c.match(/italic|-mathit/)&&(s.fontstyle="italic"))):c&&(s.mathvariant=c);let u=t.create("token","mtext",s,f(o));h.setProperty(u,"unicode",!0),t.Push(u)},RawUnicode(t,e){const n=t.GetArgument(e).trim();if(!n.match(/^[0-9A-F]{1,6}$/))throw new l("BadRawUnicode","Argument to %1 must a hexadecimal number with 1 to 6 digits",t.currentCS);const a=parseInt(n,16);t.string=String.fromCodePoint(a)+t.string.substring(t.i),t.i=0},Char(t,e){let n,a=t.GetNext(),i="";const o=t.string.substring(t.i);if("'"===a){if(n=o.match(/^'(?:([0-7]{1,7}) ?|(\\\S)|(.))/u),n)if(n[1])i=String.fromCodePoint(parseInt(n[1],8));else if(n[3])i=n[3];else{t.i+=2;const e=[...t.GetCS()];if(e.length>1)throw new l("InvalidAlphanumeric","Invalid alphanumeric constant for %1",t.currentCS);i=e[0],n=[""]}}else'"'===a?(n=o.match(/^"([0-9A-F]{1,6}) ?/),n&&(i=String.fromCodePoint(parseInt(n[1],16)))):(n=o.match(/^([0-9]{1,7}) ?/),n&&(i=String.fromCodePoint(parseInt(n[1]))));if(!i)throw new l("MissingNumber","Missing numeric constant for %1",t.currentCS);t.i+=n[0].length,i>="0"&&i<="9"?t.Push(t.create("token","mn",{},i)):i.match(/[A-Za-z]/)?t.Push(t.create("token","mi",{},i)):x(t,i)}};new d("unicode",{unicode:b.Unicode,U:b.RawUnicode,char:b.Char});const C=s.create("unicode",{[o.HANDLER]:{[r.MACRO]:["unicode"]}});MathJax.loader&&MathJax.loader.checkVersion("[tex]/unicode","4.0.0-beta.7","tex-extension"),a({_:{input:{tex:{unicode:{UnicodeConfiguration:e}}}}})})();