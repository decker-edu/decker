(()=>{"use strict";var e={d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{balanceRules:()=>E,clearDocument:()=>H,getProperty:()=>j,makeBsprAttributes:()=>G,removeProperty:()=>D,saveDocument:()=>K,setProperty:()=>q});var n={};e.r(n),e.d(n,{ProofTreeItem:()=>Q});var o={};e.r(o),e.d(o,{default:()=>Z});var r={};e.r(r),e.d(r,{BussproofsConfiguration:()=>re});const i=("undefined"!=typeof window?window:global).MathJax._.components.global,a=(i.GLOBAL,i.isObject,i.combineConfig,i.combineDefaults,i.combineWithMathJax),l=(i.MathJax,MathJax._.input.tex.HandlerTypes),s=l.ConfigurationType,d=l.HandlerType,c=MathJax._.input.tex.Configuration,f=c.Configuration,p=(c.ConfigurationHandler,c.ParserConfiguration,MathJax._.input.tex.TexError.default),u=MathJax._.input.tex.StackItem,h=(u.MmlStack,u.BaseItem),m=MathJax._.input.tex.Stack.default,g=MathJax._.input.tex.NodeUtil.default,y=MathJax._.input.tex.UnitUtil.UnitUtil;let P=null,w=null,x=function(e){w.root=e;let{w:t}=P.outputJax.getBBox(w,P);return t},T=function(e){let t=0;for(;e&&!g.isType(e,"mtable");){if(g.isType(e,"text"))return null;g.isType(e,"mrow")?(e=e.childNodes[0],t=0):(e=e.parent.childNodes[t],t++)}return e},b=function(e,t){return e.childNodes["up"===t?1:0].childNodes[0].childNodes[0].childNodes[0].childNodes[0]},M=function(e,t){return e.childNodes[t].childNodes[0].childNodes[0]},N=function(e){return M(e,0)},C=function(e){return M(e,e.childNodes.length-1)},I=function(e,t){return e.childNodes["up"===t?0:1].childNodes[0].childNodes[0].childNodes[0]},L=function(e){for(;e&&!g.isType(e,"mtd");)e=e.parent;return e},S=function(e){return e.parent.childNodes[e.parent.childNodes.indexOf(e)+1]},k=function(e){for(;e&&null==j(e,"inference");)e=e.parent;return e},A=function(e,t,n=!1){let o=0;if(e===t)return o;if(e!==t.parent){let r=e.childNodes,i=n?r.length-1:0;g.isType(r[i],"mspace")&&(o+=x(r[i])),e=t.parent}if(e===t)return o;let r=e.childNodes,i=n?r.length-1:0;return r[i]!==t&&(o+=x(r[i])),o},R=function(e,t=!1){let n=T(e),o=I(n,j(n,"inferenceRule"));return A(e,n,t)+(x(n)-x(o))/2},v=function(e,t,n,o=!1){if(0===n)return;if(j(t,"inferenceRule")||j(t,"labelledRule")){const n=e.nodeFactory.create("node","mrow");t.parent.replaceChild(n,t),n.setChildren([t]),B(t,n),t=n}const r=o?t.childNodes.length-1:0;let i=t.childNodes[r];g.isType(i,"mspace")?g.setAttribute(i,"width",y.em(y.dimen2em(g.getAttribute(i,"width"))+n)):(i=e.nodeFactory.create("node","mspace",[],{width:y.em(n)}),o?t.appendChild(i):(i.parent=t,t.childNodes.unshift(i)))},B=function(e,t){["inference","proof","labelledRule"].forEach((n=>{let o=j(e,n);null!=o&&(q(t,n,o),D(e,n))}))};const J=function(e,t,n,o,r){let i=e.nodeFactory.create("node","mspace",[],{width:y.em(r)});if("left"===o){let e=t.childNodes[n].childNodes[0];i.parent=e,e.childNodes.unshift(i)}else t.childNodes[n].appendChild(i);q(t.parent,"sequentAdjust_"+o,r)},O=function(e,t){let n=t.pop();for(;t.length;){let o=t.pop(),[r,i]=_(n,o);j(n.parent,"axiom")&&(J(e,r<0?n:o,0,"left",Math.abs(r)),J(e,i<0?n:o,2,"right",Math.abs(i))),n=o}},_=function(e,t){const n=x(e.childNodes[2]),o=x(t.childNodes[2]);return[x(e.childNodes[0])-x(t.childNodes[0]),n-o]};let E=function(e){w=new e.document.options.MathItem("",null,e.math.display);let t=e.data;!function(e){let t=e.nodeLists.sequent;if(t)for(let n,o=t.length-1;n=t[o];o--){if(j(n,"sequentProcessed")){D(n,"sequentProcessed");continue}let t=[],o=k(n);if(1===j(o,"inference")){for(t.push(n);1===j(o,"inference");){o=T(o);let e=N(b(o,j(o,"inferenceRule"))),r=j(e,"inferenceRule")?I(e,j(e,"inferenceRule")):e;j(r,"sequent")&&(n=r.childNodes[0],t.push(n),q(n,"sequentProcessed",!0)),o=e}O(e,t)}}}(t);let n=t.nodeLists.inference||[],o=0;for(let e of n){let n=j(e,"proof"),r=T(e),i=b(r,j(r,"inferenceRule")),a=N(i),l=0;if(j(a,"inference")){let n=R(a);if(n){v(t,a,-n);let o=A(e,r,!1);v(t,e,n-o),l=n-o}}let s=C(i);if(null==j(s,"inference"))continue;let d=R(s,!0);v(t,s,-d,!0);let c=A(e,r,!0);const f=(x(r)-x(i.parent))/2;let p;if(v(t,e,f<l?-f:-l),o=Math.max(0,Math.max(0,o+d-c)-f),n||!(p=L(e))){v(t,j(e,"proof")?e:e.parent,o,!0);continue}let u=S(p);if(u){const e=t.nodeFactory.create("node","mspace",[],{width:y.em(o)});u.appendChild(e),o=0}else k(p)}};const F="bspr_",U=RegExp("^"+F);let q=function(e,t,n){g.setProperty(e,F+t,n)},j=function(e,t){return g.getProperty(e,F+t)},D=function(e,t){e.removeProperty(F+t)},G=function(e){e.data.root.walkTree(((e,t)=>{let n=[];e.getPropertyNames().forEach((t=>{t.match(U)&&n.push(t+":"+e.getProperty(t))})),n.length&&g.setAttribute(e,"semantics",n.join(";"))}))},K=function(e){if(P=e.document,!("getBBox"in P.outputJax))throw Error("The bussproofs extension requires an output jax with a getBBox() method")},H=function(e){P=null};class Q extends h{constructor(){super(...arguments),this.leftLabel=null,this.rigthLabel=null,this.innerStack=new m(this.factory,{},!0)}get kind(){return"proofTree"}checkItem(e){if(e.isKind("end")&&"prooftree"===e.getName()){let t=this.toMml();return q(t,"proof",!0),[[this.factory.create("mml",t),e],!0]}if(e.isKind("stop"))throw new p("EnvMissingEnd","Missing \\end{%1}",this.getName());return this.innerStack.Push(e),h.fail}toMml(){const e=super.toMml(),t=this.innerStack.Top();if(t.isKind("start")&&!t.Size())return e;this.innerStack.Push(this.factory.create("stop"));let n=this.innerStack.Top().toMml();return this.create("node","mrow",[n,e],{})}}const V=MathJax._.input.tex.TexParser.default,z=MathJax._.input.tex.ParseUtil,$=(z.KeyValueType,z.KeyValueTypes,z.ParseUtil);function W(e,t){let n=$.internalMath(e,y.trimSpaces(t),0);if(!n[0].childNodes[0].childNodes.length)return e.create("node","mrow",[]);let o=e.create("node","mspace",[],{width:".5ex"}),r=e.create("node","mspace",[],{width:".5ex"});return e.create("node","mrow",[o,...n,r])}function X(e,t,n,o,r,i,a){const l=e.create("node","mtr",[e.create("node","mtd",[t],{})],{}),s=e.create("node","mtr",[e.create("node","mtd",n,{})],{});let d,c,f,p,u=e.create("node","mtable",a?[s,l]:[l,s],{align:"top 2",rowlines:i,framespacing:"0 0"});if(q(u,"inferenceRule",a?"up":"down"),o&&(d=e.create("node","mpadded",[o],{height:".25em",depth:"+.25em",width:"+.5ex",voffset:"-.25em"}),q(d,"prooflabel","left")),r&&(c=e.create("node","mpadded",[r],{height:"-.25em",depth:"+.25em",width:"+.5ex",voffset:"-.25em",lspace:".5ex"}),q(c,"prooflabel","right")),o&&r)f=[d,u,c],p="both";else if(o)f=[d,u],p="left";else{if(!r)return u;f=[u,c],p="right"}return u=e.create("node","mrow",f),q(u,"labelledRule",p),u}function Y(e,t){if("$"!==e.GetNext())throw new p("IllegalUseOfCommand","Use of %1 does not match its definition.",t);e.i++;let n=e.GetUpTo(t,"$");if(-1===n.indexOf("\\fCenter"))throw new p("MissingProofCommand","Missing %1 in %2.","\\fCenter",t);let[o,r]=n.split("\\fCenter"),i=new V(o,e.stack.env,e.configuration).mml(),a=new V(r,e.stack.env,e.configuration).mml(),l=new V("\\fCenter",e.stack.env,e.configuration).mml();const s=e.create("node","mtd",[i],{}),d=e.create("node","mtd",[l],{}),c=e.create("node","mtd",[a],{}),f=e.create("node","mtr",[s,d,c],{}),u=e.create("node","mtable",[f],{columnspacing:".5ex",columnalign:"center 2"});return q(u,"sequent",!0),e.configuration.addNode("sequent",f),u}const Z={Prooftree:(e,t)=>(e.Push(t),e.itemFactory.create("proofTree").setProperties({name:t.getName(),line:"solid",currentLine:"solid",rootAtTop:!1})),Axiom(e,t){let n=e.stack.Top();if("proofTree"!==n.kind)throw new p("IllegalProofCommand","Proof commands only allowed in prooftree environment.");let o=W(e,e.GetArgument(t));q(o,"axiom",!0),n.Push(o)},Inference(e,t,n){let o=e.stack.Top();if("proofTree"!==o.kind)throw new p("IllegalProofCommand","Proof commands only allowed in prooftree environment.");if(o.Size()<n)throw new p("BadProofTree","Proof tree badly specified.");const r=o.getProperty("rootAtTop"),i=1!==n||o.Peek()[0].childNodes.length?n:0;let a=[];do{a.length&&a.unshift(e.create("node","mtd",[],{})),a.unshift(e.create("node","mtd",[o.Pop()],{rowalign:r?"top":"bottom"})),n--}while(n>0);let l=e.create("node","mtr",a,{}),s=e.create("node","mtable",[l],{framespacing:"0 0"}),d=W(e,e.GetArgument(t)),c=o.getProperty("currentLine");c!==o.getProperty("line")&&o.setProperty("currentLine",o.getProperty("line"));let f=X(e,s,[d],o.getProperty("left"),o.getProperty("right"),c,r);o.setProperty("left",null),o.setProperty("right",null),q(f,"inference",i),e.configuration.addNode("inference",f),o.Push(f)},Label(e,t,n){let o=e.stack.Top();if("proofTree"!==o.kind)throw new p("IllegalProofCommand","Proof commands only allowed in prooftree environment.");let r=$.internalMath(e,e.GetArgument(t),0),i=r.length>1?e.create("node","mrow",r,{}):r[0];o.setProperty(n,i)},SetLine(e,t,n,o){let r=e.stack.Top();if("proofTree"!==r.kind)throw new p("IllegalProofCommand","Proof commands only allowed in prooftree environment.");r.setProperty("currentLine",n),o&&r.setProperty("line",n)},RootAtTop(e,t,n){let o=e.stack.Top();if("proofTree"!==o.kind)throw new p("IllegalProofCommand","Proof commands only allowed in prooftree environment.");o.setProperty("rootAtTop",n)},AxiomF(e,t){let n=e.stack.Top();if("proofTree"!==n.kind)throw new p("IllegalProofCommand","Proof commands only allowed in prooftree environment.");let o=Y(e,t);q(o,"axiom",!0),n.Push(o)},FCenter(e,t){},InferenceF(e,t,n){let o=e.stack.Top();if("proofTree"!==o.kind)throw new p("IllegalProofCommand","Proof commands only allowed in prooftree environment.");if(o.Size()<n)throw new p("BadProofTree","Proof tree badly specified.");const r=o.getProperty("rootAtTop"),i=1!==n||o.Peek()[0].childNodes.length?n:0;let a=[];do{a.length&&a.unshift(e.create("node","mtd",[],{})),a.unshift(e.create("node","mtd",[o.Pop()],{rowalign:r?"top":"bottom"})),n--}while(n>0);let l=e.create("node","mtr",a,{}),s=e.create("node","mtable",[l],{framespacing:"0 0"}),d=Y(e,t),c=o.getProperty("currentLine");c!==o.getProperty("line")&&o.setProperty("currentLine",o.getProperty("line"));let f=X(e,s,[d],o.getProperty("left"),o.getProperty("right"),c,r);o.setProperty("left",null),o.setProperty("right",null),q(f,"inference",i),e.configuration.addNode("inference",f),o.Push(f)}},ee=MathJax._.input.tex.ParseMethods.default,te=MathJax._.input.tex.TokenMap,ne=(te.parseResult,te.AbstractTokenMap,te.RegExpMap,te.AbstractParseMap,te.CharacterMap,te.DelimiterMap,te.MacroMap,te.CommandMap),oe=te.EnvironmentMap;new ne("Bussproofs-macros",{AxiomC:Z.Axiom,UnaryInfC:[Z.Inference,1],BinaryInfC:[Z.Inference,2],TrinaryInfC:[Z.Inference,3],QuaternaryInfC:[Z.Inference,4],QuinaryInfC:[Z.Inference,5],RightLabel:[Z.Label,"right"],LeftLabel:[Z.Label,"left"],AXC:Z.Axiom,UIC:[Z.Inference,1],BIC:[Z.Inference,2],TIC:[Z.Inference,3],RL:[Z.Label,"right"],LL:[Z.Label,"left"],noLine:[Z.SetLine,"none",!1],singleLine:[Z.SetLine,"solid",!1],solidLine:[Z.SetLine,"solid",!1],dashedLine:[Z.SetLine,"dashed",!1],alwaysNoLine:[Z.SetLine,"none",!0],alwaysSingleLine:[Z.SetLine,"solid",!0],alwaysSolidLine:[Z.SetLine,"solid",!0],alwaysDashedLine:[Z.SetLine,"dashed",!0],rootAtTop:[Z.RootAtTop,!0],alwaysRootAtTop:[Z.RootAtTop,!0],rootAtBottom:[Z.RootAtTop,!1],alwaysRootAtBottom:[Z.RootAtTop,!1],fCenter:Z.FCenter,Axiom:Z.AxiomF,UnaryInf:[Z.InferenceF,1],BinaryInf:[Z.InferenceF,2],TrinaryInf:[Z.InferenceF,3],QuaternaryInf:[Z.InferenceF,4],QuinaryInf:[Z.InferenceF,5]}),new oe("Bussproofs-environments",ee.environment,{prooftree:[Z.Prooftree,null,!1]});const re=f.create("bussproofs",{[s.HANDLER]:{[d.MACRO]:["Bussproofs-macros"],[d.ENVIRONMENT]:["Bussproofs-environments"]},[s.ITEMS]:{[Q.prototype.kind]:Q},[s.PREPROCESSORS]:[[K,1]],[s.POSTPROCESSORS]:[[H,3],[G,2],[E,1]]});MathJax.loader&&MathJax.loader.checkVersion("[tex]/bussproofs","4.0.0-beta.7","tex-extension"),a({_:{input:{tex:{bussproofs:{BussproofsConfiguration:r,BussproofsItems:n,BussproofsMethods:o,BussproofsUtil:t}}}}})})();