/**
 * A plugin which enables rendering of math equations inside
 * of reveal.js slides. Essentially a thin wrapper for MathJax.
 *
 * @author Hakim El Hattab
 * @author Mario Botsch
 *
 * Initial version by Hakim El Hattab.
 * Modifications by Decker team:
 * - upgrade to MathJax v3
 * - disable math typesetting on each slide change
 * - disable SVG font caches, since it doesn't work in speaker notes
 * - use promise mechanism to ensure that math is typeset before PDF print
 * - fix links generated by referencing equations to jump to the slide
 *   containing the referenced equation
 * - inject class=fragment to incrementally show multi-line equations
 *   (if MathJax element in enclosed in div.math-incremental)
 * - define Latex macro \fragment{...} to show equations part-by-part
 * - inject CSS rules to fit equations to their container and to make
 *   Reveal's zoom plugin work on equations.
 * - upgrade to MathJax v4
 */

import {
  injectMathJaxCSS,
  configureMathJax,
  loadMathJax,
} from "../../js/mathjax.js";

// This module's reference to Reveal
let Reveal;

function adjustLinksDocument(doc) {
  for (const item of doc.math) {
    adjustLinksItem(item, doc);
  }
}

function adjustLinksItem(item, doc) {
  const root = item.typesetRoot;
  if (root) {
    const anchors = root.querySelectorAll("a");
    for (const anchor of anchors) {
      const href = anchor.href;
      if (href.baseVal) {
        let label = href.baseVal;
        if (label.includes("#mjx-eqn")) {
          label = decodeURIComponent(label.substring(1));
          const eqn = document.getElementById(label);
          if (eqn) {
            const s = eqn.closest("section");
            if (s) {
              anchor.href.baseVal =
                location.origin +
                location.pathname +
                location.search +
                "#" +
                s.id;
            }
          }
        }
      }
    }
  }
}

function incrementalDocument(doc) {
  for (const item of doc.math) {
    incrementalItem(item, doc);
  }
}

function incrementalItem(item, mdoc) {
  const doc = document.documentElement;
  const root = item.typesetRoot;
  if (root && root.closest(".math-incremental")) {
    for (let mrow of root.querySelectorAll(
      'g[data-mml-node="mtable"]:first-of-type > g[data-mml-node="mtr"]'
    )) {
      mrow.classList.add("fragment");
      if (doc.classList.contains("handout") || doc.classList.contains("a11y")) {
        mrow.classList.add("visible");
      }
    }
    for (let mrow of root.querySelectorAll(
      'g[data-mml-node="mtable"]:first-of-type g[data-mml-node="mlabeledtr"]'
    )) {
      mrow.classList.add("fragment");
      if (doc.classList.contains("handout") || doc.classList.contains("a11y")) {
        mrow.classList.add("visible");
      }
    }
  }
}

/*
/*
 * remove fragments from assistive MML blocks
 */
function fixAssistiveMML(doc) {
  for (let elem of document.querySelectorAll("mjx-assistive-mml .fragment")) {
    elem.classList.remove("fragment");
  }
}

const Plugin = {
  id: "math",

  init: (deck) => {
    Reveal = deck;

    /* Return a promise to reveal to make it wait until startup.promise resolves. */
    return new Promise((resolve) => {
      injectMathJaxCSS();
      configureMathJax();

      window.MathJax.startup.ready = () => {
        const startTime = performance.now();
        console.log("MathJax start");
        MathJax.startup.defaultReady();
        MathJax.startup.promise.then(() => {
          const endTime = performance.now();
          const timeTaken = endTime - startTime;
          console.log(`mathjax took ${timeTaken} milliseconds`);
          resolve();
        });
      };

      window.MathJax.options.renderActions = {
        incremental: [1000, incrementalDocument, incrementalItem, false],
        adjustLinks: [1001, adjustLinksDocument, adjustLinksItem, false],
        fixmml: [1002, fixAssistiveMML, "", false],
      };

      loadMathJax();
    });
  },
};

export default Plugin;
