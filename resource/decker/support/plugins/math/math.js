/**
 * A plugin which enables rendering of math equations inside
 * of reveal.js slides. Essentially a thin wrapper for MathJax.
 *
 * @author Hakim El Hattab
 * @author Mario Botsch
 *
 * Initial version by Hakim El Hattab.
 * Modifications by Mario Botsch:
 * - upgrade to MathJax v3
 * - disable math typesetting on each slide change
 * - disable SVG font caches, since it doesn't work in speaker notes
 * - use promise mechanism to ensure that math is typset before PDF print
 * - fix links generated by referencing equations to jump to the slide
 *   containing the referenced equation
 * - inject class=fragment to incrementally show multi-line equations
 *   (if MathJax element in enclosed in div.math-incremental)
 * - define Latex macro \fragment{...} to show equations part-by-part
 * - inject CSS rules to fit equations to their container and to make
 *   Reveal's zoom plugin work on equations.
 */

// This module's reference to Reveal
let Reveal;

function loadScript(url, callback) {
  const head = document.querySelector("head");
  let script = document.createElement("script");
  script.type = "text/javascript";
  script.id = "MathJax-script";
  script.src = url;

  // Wrapper for callback to make sure it only fires once
  function finish() {
    if (typeof callback === "function") {
      callback.call();
      callback = null;
    }
  }

  script.onload = finish;

  // IE
  script.onreadystatechange = function () {
    if (this.readyState === "loaded") {
      finish();
    }
  };

  // Normal browsers
  head.appendChild(script);
}

function adjustLinksDocument(doc) {
  for (const item of doc.math) {
    adjustLinksItem(item, doc);
  }
}

function adjustLinksItem(item, doc) {
  const root = item.typesetRoot;
  if (root) {
    const anchors = root.querySelectorAll("a");
    for (const anchor of anchors) {
      const href = anchor.href;
      if (href.baseVal) {
        let label = href.baseVal;
        if (label.includes("#mjx-eqn")) {
          label = decodeURIComponent(label.substring(1));
          const eqn = document.getElementById(label);
          if (eqn) {
            const s = eqn.closest("section");
            if (s) {
              anchor.href.baseVal =
                location.origin +
                location.pathname +
                location.search +
                "#" +
                s.id;
            }
          }
        }
      }
    }
  }
}

function incrementalDocument(doc) {
  for (const item of doc.math) {
    incrementalItem(item, doc);
  }
}

function incrementalItem(item, mdoc) {
  const doc = document.documentElement;
  const root = item.typesetRoot;
  if (root && root.closest(".math-incremental")) {
    for (let mrow of root.querySelectorAll(
      'g[data-mml-node="mtable"]:first-of-type > g[data-mml-node="mtr"]'
    )) {
      mrow.classList.add("fragment");
      if (doc.classList.contains("handout") || doc.classList.contains("a11y")) {
        mrow.classList.add("visible");
      }
    }
    for (let mrow of document.querySelectorAll(
      'g[data-mml-node="mtable"]:first-of-type g[data-mml-node="mlabeledtr"]'
    )) {
      mrow.classList.add("fragment");
      if (doc.classList.contains("handout") || doc.classList.contains("a11y")) {
        mrow.classList.add("visible");
      }
    }
  }
}

/*
/*
 * remove fragments from assistive MML blocks
 */
function fixAssistiveMML(doc) {
  for (let elem of document.querySelectorAll("mjx-assistive-mml .fragment")) {
    elem.classList.remove("fragment");
  }
}

/*
 * Inject CSS rules that (i) make SVG equations automatically shrink down to
 * fit the enclosing container and (ii) remove pointer events from the
 * equation parts, such that Reveal's zoom plugin work nicely on equations, too.
 */
function injectStyle() {
  const style = document.createElement("style");
  style.textContent = String.raw`
            /* fit equation into container (disable for tables) */
            mjx-container > svg:not(table mjx-container > svg) {
                object-fit: contain;
                max-width: 100%;
            }

            /* don't (dbl)click/zoom SVG interiors */
            mjx-container > svg * {
                pointer-events: none;
            }

            /* eqn refs have to be clickable */
            mjx-container > svg a, 
            mjx-container > svg a * {
                pointer-events: all;
            }
        `;
  document.head.append(style);
}

// Is initial a11y mode requested?
const a11y = /a11y/gi.test(window.location.search);

const Plugin = {
  id: "math",

  init: (deck) => {
    Reveal = deck;

    // get configuration, built MathJax URL
    const options = Reveal.getConfig().math || {};
    if (!options.mathjax) {
      console.error(
        "No MathJax source URI has been configured. This should not happen!",
        "The config.math.mathjax value is usually configured in your resource pack's 'deck.html'",
        "Please contact the developers: https://github.com/decker-edu/decker"
      );
      return;
    }
    const url = options.mathjax + "tex-svg.js";

    // define \fragment{...} funtion
    let macros = { fragment: ["\\class{fragment}{#1}", 1] };
    // add user-defined Latex macros
    if (options.macros) {
      macros = Object.assign(macros, options.macros);
    }

    const language = Decker.meta.lang || navigator.language;

    /* MathJax configuration object */
    window.MathJax = {
      startup: {
        ready: () => {
          /* Workaround to allow loading of a11y features past initial load
           * Necessary due do a bug in 3.2.2 throwing a Mathjax.retry error. */
          const { mathjax } = window.MathJax._.mathjax;
          const { STATE } = window.MathJax._.core.MathItem;
          const { Menu } = window.MathJax._.ui.menu.Menu;
          const rerender = Menu.prototype.rerender;
          Menu.prototype.rerender = function (start = STATE.TYPESET) {
            mathjax.handleRetriesFor(() => {
              rerender.call(this, start);
            });
          };
        },
      },
      svg: {
        scale: window.Decker.meta.math.scale || 1.0, // global scaling factor for all expressions
        minScale: 0.5, // smallest scaling factor to use
        mtextInheritFont: true, // true to make mtext elements use surrounding font
        merrorInheritFont: true, // true to make merror text use surrounding font
        mathmlSpacing: false, // true for MathML spacing rules, false for TeX rules
        skipAttributes: {}, // RFDa and other attributes NOT to copy to the output
        exFactor: 0.5, // default size of ex in em units
        displayAlign: "center", // default for indentalign when set to 'auto'
        displayIndent: "0", // default for indentshift when set to 'auto'
        fontCache: "none", // or 'global' or 'none'
        localID: null, // ID to use for local font cache (for single equation processing)
        internalSpeechTitles: true, // insert <title> tags with speech content
        titleID: 0, // initial id number to use for aria-labeledby titles
      },
      tex: {
        tags: "ams",
        inlineMath: [
          // start/end delimiter pairs for in-line math
          ["$", "$"],
          ["\\(", "\\)"],
        ],
        displayMath: [
          // start/end delimiter pairs for display math
          ["$$", "$$"],
          ["\\[", "\\]"],
        ],
        macros: macros,
      },
      options: {
        renderActions: {
          incremental: [1000, incrementalDocument, incrementalItem, false],
          adjustLinks: [1001, adjustLinksDocument, adjustLinksItem, false],
          fixmml: [1002, fixAssistiveMML, "", false],
        },
        sre: {
          locale: language === "de" ? "de" : "en",
        },
        enableMenu: a11y,
        menuOptions: {
          settings: {
            explorer: a11y, //if in a11y page mode: active by default
          },
        },
        a11y: {
          backgroundColor: "Green",
          backgroundOpacity: 50,
          foregroundColor: "Black",
          foregroundOpacity: 100,
        },
      },
    };

    injectStyle();

    /* Return a promise to reveal to make it wait until startup.promise resolves. */
    return new Promise((resolve) => {
      loadScript(url, () => {
        window.MathJax.startup.promise.then(() => {
          Reveal.layout();
          resolve();
        });
        window.MathJax.startup.defaultReady();
      });
    });
  },
};

export default Plugin;
